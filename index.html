<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Mouse memory doom</title>
<style>
body { margin: 0; }
canvas { width: 100%; height: calc(100vh - 40px); background: black; display: block; }
h1 { text-align: center; position: relative; }
#overlay { position: absolute; right: 10px; top: 0; height: 40px; display: flex; align-items: center; gap: 10px; }
#shadow {
  position: fixed;
  left: 0; top: 0;
  width: 32px; height: 32px; /* big enough for any cursor */
  pointer-events: none; /* let clicks go through */
  z-index: 9999;
}
.cursor {
  position: fixed;
  left: 0; top: 0;
  width: 32px; height: 32px;
  pointer-events: none;
  z-index: 9999;
}
</style>
</head>
<body>
<h1>Mouse mermory doom</h1>
<div id="app">
  <div id="overlay">
    <span>{{ count }}</span>
    <button @click="clear">Clear</button>
  </div>
  <canvas></canvas>
</div>
<div id="shadow"></div>
<script src="/vue.js"></script>
<script>
const { createApp, ref, onMounted } = Vue;

createApp({
  setup() {
    const canvas = ref(null);
    const count = ref(0);
    let ctx;
    let shadow;
    let currentPath = [];
    const pointers = [];

    function createCursor(color) {
      const el = document.createElement('div');
      el.className = 'cursor';
      el.style.background = color;
      document.body.appendChild(el);
      return el;
    }

    function fetchRecords() {
      fetch('/records')
        .then(r => r.json())
        .then(json => {
          if (Array.isArray(json.records)) {
            json.records.forEach(rec => {
              const color = colorFor(pointers.length);
              pointers.push({ path: rec, start: Date.now(), color, elem: createCursor(color), trail: [] });
            });
            while (pointers.length > 100) {
              const old = pointers.shift();
              if (old.elem) document.body.removeChild(old.elem);
            }
            updateCount();
          }
        })
        .catch(() => { });
    }

    function clearAll() {
      fetch('/records', { method: 'DELETE' }).catch(() => { });
      while (pointers.length) {
        const p = pointers.pop();
        if (p.elem) document.body.removeChild(p.elem);
      }
      currentPath = [];
      updateCount();
    }

    function updateCount() {
      count.value = pointers.length;
    }

    function record(e) {
      const rect = canvas.value.getBoundingClientRect();
      const x = e.clientX - rect.left - rect.width / 2;
      const y = e.clientY - rect.top - rect.height / 2;
      currentPath.push({ x, y, t: Date.now() });
    }

    function colorFor(index) {
      const base = 255 - Math.min(index, 50) * 5; // about 2%
      const c = Math.max(0, base);
      return `rgb(${c},${c},${c})`;
    }

    function sendRecords() {
      if (currentPath.length === 0) return;
      fetch('/records', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ records: currentPath })
      })
        .then(r => r.json())
        .then(json => {
          if (Array.isArray(json.records)) {
            json.records.forEach(rec => {
              const color = colorFor(pointers.length);
              pointers.push({ path: rec, start: Date.now(), color, elem: createCursor(color), trail: [] });
            });
            while (pointers.length > 100) pointers.shift();
            updateCount();
          }
        })
        .catch(() => { });

      const color = colorFor(pointers.length);
      pointers.push({ path: currentPath, start: Date.now(), color, elem: createCursor(color), trail: [] });
      while (pointers.length > 100) {
        const old = pointers.shift();
        if (old.elem) document.body.removeChild(old.elem);
      }
      updateCount();
      currentPath = [];
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.value.width, canvas.value.height);
      const now = Date.now();
      for (let i = 0; i < pointers.length; i++) {
        const p = pointers[i];
        const elapsed = now - p.start;
        let pos = p.path[0];
        for (let j = 0; j < p.path.length; j++) {
          const step = p.path[j];
          if (elapsed >= step.t - p.path[0].t) {
            pos = step;
          } else {
            break;
          }
        }
        const x = canvas.value.width / 2 + pos.x;
        const y = canvas.value.height / 2 + pos.y;
        p.elem.style.left = x + 'px';
        p.elem.style.top = y + 'px';
        p.trail.push({ x, y, t: now });
        while (p.trail.length && now - p.trail[0].t > 1000) p.trail.shift();
        ctx.strokeStyle = p.color;
        ctx.beginPath();
        for (let j = 0; j < p.trail.length; j++) {
          const pt = p.trail[j];
          if (j === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
      }
      requestAnimationFrame(draw);
    }

    onMounted(() => {
      const c = canvas.value = document.querySelector('#app canvas');
      c.width = c.clientWidth;
      c.height = c.clientHeight;
      ctx = c.getContext('2d');
      shadow = document.getElementById('shadow');
      document.addEventListener('mousemove', e => {
        shadow.style.left = e.clientX + 'px';
        shadow.style.top = e.clientY + 'px';
      });
      c.addEventListener('mousemove', record);
      setInterval(sendRecords, 15000);
      fetchRecords();
      draw();
    });

    return { canvas, count, clear: clearAll };
  }
}).mount('#app');
</script>
</body>
</html>
