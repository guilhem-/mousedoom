<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Mouse memory doom</title>
<style>
body { margin: 0; }
canvas { width: 100%; height: calc(100vh - 40px); background: black; display: block; }
h1 { text-align: center; position: relative; }
#overlay { position: absolute; right: 10px; top: 0; height: 40px; display: flex; align-items: center; gap: 10px; }
</style>
</head>
<body>
<h1>Mouse mermory doom</h1>
<div id="overlay">
  <span>{{ count }}</span>
  <button @click="clear">Clear</button>
</div>
<div id="app">
  <canvas></canvas>
</div>
<script src="/vue.js"></script>
<script>
const { createApp, ref, onMounted } = Vue;

createApp({
  setup() {
    const canvas = ref(null);
    const count = ref(0);
    let ctx;
    let currentPath = [];
    const pointers = [];

    function fetchRecords() {
      fetch('/records')
        .then(r => r.json())
        .then(json => {
          if (Array.isArray(json.records)) {
            json.records.forEach(rec => {
              pointers.push({ path: rec, start: Date.now(), color: colorFor(pointers.length) });
            });
            while (pointers.length > 100) pointers.shift();
            updateCount();
          }
        })
        .catch(() => { });
    }

    function clearAll() {
      fetch('/records', { method: 'DELETE' }).catch(() => { });
      pointers.length = 0;
      currentPath = [];
      updateCount();
    }

    function updateCount() {
      count.value = pointers.length;
    }

    function record(e) {
      const rect = canvas.value.getBoundingClientRect();
      const x = e.clientX - rect.left - rect.width / 2;
      const y = e.clientY - rect.top - rect.height / 2;
      currentPath.push({ x, y, t: Date.now() });
    }

    function colorFor(index) {
      const base = 255 - Math.min(index, 50) * 5; // about 2%
      const c = Math.max(0, base);
      return `rgb(${c},${c},${c})`;
    }

    function drawPointer(x, y, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 10, y + 4);
      ctx.lineTo(x + 4, y + 6);
      ctx.lineTo(x + 6, y + 14);
      ctx.closePath();
      ctx.fill();
    }

    function sendRecords() {
      if (currentPath.length === 0) return;
      fetch('/records', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ records: currentPath })
      })
        .then(r => r.json())
        .then(json => {
          if (Array.isArray(json.records)) {
            json.records.forEach(rec => {
              pointers.push({ path: rec, start: Date.now(), color: colorFor(pointers.length) });
            });
            while (pointers.length > 100) pointers.shift();
            updateCount();
          }
        })
        .catch(() => { });

      pointers.push({ path: currentPath, start: Date.now(), color: colorFor(pointers.length) });
      while (pointers.length > 100) pointers.shift();
      updateCount();
      currentPath = [];
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.value.width, canvas.value.height);
      const now = Date.now();
      for (let i = 0; i < pointers.length; i++) {
        const p = pointers[i];
        const elapsed = now - p.start;
        let pos = p.path[0];
        for (let j = 0; j < p.path.length; j++) {
          const step = p.path[j];
          if (elapsed >= step.t - p.path[0].t) {
            pos = step;
          } else {
            break;
          }
        }
        drawPointer(canvas.value.width / 2 + pos.x, canvas.value.height / 2 + pos.y, p.color);
      }
      requestAnimationFrame(draw);
    }

    onMounted(() => {
      const c = canvas.value = document.querySelector('#app canvas');
      c.width = c.clientWidth;
      c.height = c.clientHeight;
      ctx = c.getContext('2d');
      c.addEventListener('mousemove', record);
      setInterval(sendRecords, 15000);
      fetchRecords();
      draw();
    });

    return { canvas, count, clear: clearAll };
  }
}).mount('#app');
</script>
</body>
</html>
